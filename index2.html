<html>

<head>
  <meta charset="utf-8">
  <title>rr: lightweight recording & deterministic debugging</title>
</head>

<body>
  <h1>rr</h1>

  <ul>
    
    <li><a href="https://github.com/mozilla/rr">github</a>
    <li><a href="https://mail.mozilla.org/listinfo/rr-dev">mailing
        list</a>
    <li><a href="https://travis-ci.org/mozilla/rr">travis-ci</a>
    <li>#research on irc.mozilla.org
  </ul>

  <section>
    <h2>rr records nondeterministic executions of applications,
      enabling you to deterministically debug the recordings.</h2>
    <p>
      rr aspires to be your primary debugging tool, replacing &mdash;
      more accurately, enhancing &mdash; gdb.  You record a failure
      once, then debug the recording, deterministically, as many times
      as you want.  Every time the same execution is replayed.
    <p>
      Here's what using rr is like.
    <p>
      <em>TODO: add to or replace with inline video demonstration.</em>
      <pre>
$ rr record /your/application --args
...
TEST-FAIL: foo
      </pre>
    <p>
      The execution of your application, including the fail of the
      test, was saved to disk.  That recording can now be debugged.
      <pre>
$ rr replay trace_0
GNU gdb (GDB) ...
...
0x4cee2050 in _start () from /lib/ld-linux.so.2
(gdb)
      </pre>
    <p>
      Remember, you're debugging the <em>recorded trace</em>
      deterministically; <em>not</em> a live, nondeterministic
      execution.  The replayed execution's address spaces, register
      contents, syscall data etc are exactly the same in every run.
    <p>
      Most of the common gdb commands can be used.  
      <pre>
(gdb) break main
Breakpoint 1 at 0x8048797: file ..., line 6.
(gdb) continue
Continuing.

Breakpoint 1, main (argc=1, argv=0xffffd694) at ...:6
...
      </pre>
    <p>
      If you need to restart the debugging session to see data
      from earlier in execution, use gdb's <code>run</code>
      command.
      <pre>
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
...
Breakpoint 1, main (argc=1, argv=0xffffd694) at ...:6
...
(gdb) 
      </pre>
    <p>
      The <code>run</code> command started another replay run of your
      recording from the beginning.  But after the session restarted,
      the <em>same execution</em> was replayed again.  All your
      debugging state was preserved across the restart, as well.
    <p>
      This technology can make your debugging more efficient.  Read on
      to learn more &hellip;
      
  </section>

  <section>
    <h2>getting started</h2>

    <div>
      <h3>fedora</h3>
      <pre>
cd /tmp
wget http://rr-project.org/releases/rr-0.5.1-Linux-$(uname -m).rpm
sudo rpm -i rr-0.5.1-Linux-$(uname -m).rpm
      </pre>
    </div>

    <div>
      <h3>ubuntu</h3>
      <pre>
cd /tmp
wget http://rr-project.org/releases/rr-0.5.1-Linux-$(uname -m).deb
sudo dpkg -i rr-0.5.1-Linux-$(uname -m).deb
      </pre>
    </div>

    <div>
      <p><a href="https://github.com/mozilla/rr/wiki/Installation">Build
            from source</a>
    </div>

    <div>
      <p>
        Follow
        the <a href="https://github.com/mozilla/rr/wiki/Usage">usage
        instructions</a> to set up your machine (if necessary) and
        learn how to use rr.
  </section>

  <section>
    <h2>background and motivation</h2>
    <p>
      Everyone who's worked on a nontrivial application
      (like <a href="httos://firefox.com">Firefox</a>) has gone
      through the pain of debugging an intermittently-reproducible
      bug.  Since nontrivial applications
      are <em>nondeterministic</em>, each execution is different, and
      you may require 5, 10, or even 100 runs just to see the bug
      manifest.
    <p>
      It's hard to debug these bugs with traditional techniques
      because single stepping, setting breakpoints, inspecting program
      state, etc, is all a waste of time if the program execution
      you're debugging ends up not even exhibiting the bug. Even when
      you can reproduce the bug consistently, important information
      such as the addresses of suspect objects is unpredictable from
      run to run. Given that software developers spend a lot of time
      finding and fixing bugs, nondeterminism has a major impact on
      their work.
    <p>
      And there are intermittent bugs that are so hard to reproduce
      that they're literally not the worth the time to fix with
      traditional techniques.  However, for big projects like Firefox
      with its half-billion users, a bug that only reproduces 1 out of
      10,000 test runs can still have a significant negative impact on
      users.
    <p>
      rr solves these problems by splitting debugging into two phases:
      first <em>recording</em>, in which the application's execution
      history is saved; then <em>deterministic debugging</em> of the
      saved trace: using gdb to control replay of the trace, as many
      times as you want.
    <p>
      The saved execution history captures all nondeterminism in the
      program's execution.  By replaying that trace in the right way,
      rr guarantees each debugging session is entirely deterministic.
      The memory layout is always the same, the addresses of objects
      don't change, register values are identical, syscalls return the
      same data, etc.
    <p>
      The benefit to developers is obvious: an intermittent bug can be
      recorded by a script over lunchtime, say, and then debugged at
      leisure in the afternoon.  Multiple cores can be used in
      parallel to record failures.  Even for easily reproducible bugs,
      a repeatable, deterministic, debugging session is a powerful
      tool on top of traditional debugging.
    <p>
      And for projects like Firefox which run literally millions of
      tests a day on a vast build and test infrastructure,
      intermittent failures in those test runs can be recorded on the
      infrastructure itself and then deterministically debugged at
      some later time, offline.
    <p>
      Tools like fuzzers and randomized fault injectors become even
      more powerful when used with rr.  Those tools are very good at
      triggering <em>some</em> intermittent failure, but it's often
      hard to reproduce <em>that same</em> failure again to debug it.
      With rr, the randomized execution can simply be recorded.  If
      the execution failed, then the saved recording can be used to
      deterministically debug the problem.
    <p>
      So rr lowers the cost of fixing intermittent bugs.  This allows
      a new class of bugs to be fixed with the same amount of
      engineering time and money, which in turn produces
      higher-quality software for the same cost.
    <p>
      Deterministic debugging is an old idea; many systems have
      preceded rr.  What makes rr different, in our opinion, are the
      design goals:
      <ul>
        <li><em>Initially focus on debugging Firefox</em>. Firefox is
          a complex application, so if rr is useful for debugging
          Firefox, it is very likely to be generally useful.  However,
          there's nothing about rr that's specific to Firefox; we've
          just spent the majority of our testing time on Firefox.  rr
          support will broaden as the project matures.
        <li><em>Prioritize deployability</em>. rr runs on a stock
          linux kernel, and requires little (Ubuntu) to no (Fedora)
          system configuration changes. And of course rr works on
          stock, relatively modern hardware.
        <li><em>Make run-time overload low</em>. We want rr to replace
          gdb in your workflow. That means you need to start getting
          results with rr about as quickly as you would if you were
          using gdb.
      </ul>
    <p>
      The overhead of rr depends on your application's workload.  On
      Firefox test suites, we generally see about a 1.2x slowdown when
      recording with rr.  That means that if the suite takes 10
      minutes to run by itself, it will take around 12 minutes to be
      recorded running under rr.
  </section>

  <section>
    <h2>limitations</h2>
    <p>
      Some of rr's limitations are inherent, and some will be removed
      in future releases.
    <p>rr &hellip;
    <ul>
      <li>emulates a single-core machine. So, parallel programs incur
        the slowdown of running on a single core. This is an inherent
        feature of the design.
      <li>cannot record processes that share memory with processes
        outside the recording tree. This is an inherent feature of the
        design. rr automatically disables features such as X shared
        memory for recorded processes to avoid this problem.
      <li>currently only supports x86 32-bit processes. x86-64 will be
        supported in the future, it's just a matter of porting work.
      <li>requires a reasonably modern x86 CPU. It depends on certain
        performance counter features that are not available in older
        CPUs, or in ARM at all currently.
      <li>requires knowledge of every system call executed by the
        recorded processes. It already supports a wide range of
        syscalls &mdash; those needed by Firefox &mdash; but support
        isn't comprehensive, so running rr on your application may
        uncover a syscall that needs to be implemented.
    </ul>
  </section>

  <section>
    <h2>further reference</h2>
    <p>
      <a href="http://rr-project.org/rr.html">This presentation</a>
      provides an overview of the rr implementation and is meant for
      potential rr developers.  There are some bonus slides intended
      to introduce rr to record/replay researchers.
    <p>
      The <a href="https://github.com/mozilla/rr/wiki">rr wiki</a>
      contains pages that cover technical topics related to rr.
    <p>
      More information about rr will be posted in the future.
  </section>

  <footer>
    <p>Copyright &copy;
    2014 <a href="http://www.mozilla.org/en-US/research/">Mozilla
    Research</a>.
</body>

</html>
